Hicimos un codigo para mover dos motores a la vez, 
unicamente como prueba para controlar un puente h(funciona):

#define ENA 9
#define ENB 10
#define IN1 3
#define IN2 4
#define IN3 5
#define IN4 6


int velocidad = 200;
void setup() {
 
  pinMode(IN1,OUTPUT);  pinMode(IN2,OUTPUT);  pinMode(ENA,OUTPUT);
  pinMode(IN3,OUTPUT);  pinMode(IN4,OUTPUT);  pinMode(ENB,OUTPUT);


}


void loop() {
  // put your main code here, to run repeatedly:
digitalWrite(IN1, HIGH);
digitalWrite(IN2, LOW);
digitalWrite(IN3, HIGH);
digitalWrite(IN4, LOW);
digitalWrite(ENA, velocidad);
digitalWrite(ENB, velocidad);
delay(3000);
digitalWrite(IN2, HIGH);
digitalWrite(IN1, LOW);
digitalWrite(IN4, HIGH);
digitalWrite(IN3, LOW);
digitalWrite(ENA, velocidad);
digitalWrite(ENB, velocidad);
delay(3000);
}

Hicimos un codigo para mover esos mismos motores pero basados en un input del usuario temporal, una serie
de botones. La idea es hacer la estructura de los condicionales, luego estas instrucciones haremos que 
lleguen de una computadora por el puerto serial (probar si funciona en un modelo L293N):

int velocidad = 200;
int boton1 = 0;
int boton2 = 0;
int boton3 = 0;
int boton4 = 0;
int respuesta = 0;
#define ENA 9
#define ENB 10
#define IN1 3
#define IN2 4
#define IN3 5
#define IN4 6


void setup() {
 Serial.begin(9600);
//Esto está puesto con pullup para aumentar la fiabilidad de la lectura, 
//pero hace que la logica se invierte(cuando esta presionado es 0 pero cuando no lo esta es 1) *CUIDADO*
 pinMode(8, INPUT_PULLUP); 
 pinMode(11,INPUT_PULLUP); 
 pinMode(12,INPUT_PULLUP); 
 pinMode(13,INPUT_PULLUP); 
 //en cambio, la logica de esto es *normal*
 pinMode(3, OUTPUT); 
 pinMode(4,OUTPUT); 
 pinMode(9,OUTPUT);
 pinMode(5,OUTPUT); 
 pinMode(6,OUTPUT); 
 pinMode(10,OUTPUT);




}




void loop() {
  // put your main code here, to run repeatedly:
  boton1 = digitalRead(8);
  boton2 = digitalRead(11);
  boton3 = digitalRead(12);
  boton4 = digitalRead(13);
  
  if (boton1 == 0){
   analogWrite(9, velocidad);
   digitalWrite (IN1,HIGH);
   digitalWrite (IN2,LOW);
   Serial.println ("motor 1 contra-reloj");
  }
  
  else if (boton2 == 0){
   analogWrite(9, velocidad);
   digitalWrite(IN2, HIGH);
   digitalWrite(IN1, LOW);
   Serial.println ("motor 1 reloj");
  }
  
  else if (boton3 == 0){
   analogWrite(10, velocidad);
   digitalWrite (IN3,HIGH);
   digitalWrite (IN4,LOW);
   Serial.println ("motor 2 contra-reloj");
  }
  
  else if (boton4 == 0){
   analogWrite(10, velocidad);
   digitalWrite(IN4, HIGH);
   digitalWrite (IN3,LOW);
   Serial.println ("motor 2 reloj");
  } 
  else {
    digitalWrite(3,LOW);
    digitalWrite(4,LOW);
    digitalWrite(5,LOW);
    digitalWrite(6,LOW);
    digitalWrite(9,LOW);
    digitalWrite(10,LOW);
  }
  
  
  delay(100);
}

Bien, vamos a tener que programar ahora como va a doblar el auto EN BASE A LOS INPUTS DEL PUERTO SERIAL, no de
botones, pero la base es la misma. El auto va a tener dos motores, uno en cada rueda trasera, y para doblar va 
desactivar uno y activar otro, algo asi como los tanques, que giran sobre su propio eje. Ademas, hicimos 
sistema que va a enviar los datos que registran los sensores de flexión 
Codigo:

//movimiento de motor
#define ENA 9
#define ENB 10
#define IN1 3
#define IN2 4
#define IN3 5
#define IN4 6
int velocidad = 200;

//detección de dedos
#define sens1 A0
#define sens2 A1
#define sens3 A2
#define sens4 A3

int dedo1 = 0;
int dedo2 = 0;
int dedo3 = 0;
int dedo4 = 0;

long max = 0;
long min = 1023;
int respuesta = 0;

String orden = "";
 // los flex sensors dan valores entre 535 y 565, asi que vamos a crear una función  que los convierta
 //en porcentaje

int conversor1 (int Valor) {
   respuesta = map(Valor, 470, 950, 0, 100);
  
  if (respuesta < 0) {
    respuesta = 0;
  }
  if (respuesta > 100) {
    respuesta = 100;
  }

  Serial.print ("dedo menique:");
  Serial.println(respuesta);
  return respuesta;
}

int conversor2 (int Valor) {
   respuesta = map(Valor, 470, 950, 0, 100);
  
  if (respuesta < 0) {
    respuesta = 0;
  }
  if (respuesta > 100) {
    respuesta = 100;
  }

  Serial.print ("dedo anular:");
  Serial.println(respuesta);
  return respuesta;
}

int conversor3 (int Valor) {
   respuesta = map(Valor, 470, 950, 0, 100);
  
  if (respuesta < 0) {
    respuesta = 0;
  }
  if (respuesta > 100) {
    respuesta = 100;
  }

  Serial.print ("dedo mayor:");
  Serial.println(respuesta);
  return respuesta;
}

int conversor4 (int Valor) {
   respuesta = map(Valor, 470, 950, 0, 100);

  if (respuesta < 0) {
    respuesta = 0;
  }
  if (respuesta > 100) {
    respuesta = 100;
  }

  Serial.print ("dedo indice:");
  Serial.println(respuesta);
  return respuesta;
}



void setup () {
 //movimiento de motor
 pinMode(3, OUTPUT); 
 pinMode(4,OUTPUT); 
 pinMode(9,OUTPUT);
 pinMode(5,OUTPUT); 
 pinMode(6,OUTPUT); 
 pinMode(10,OUTPUT);
 Serial.begin (9600);
 //detección de dedos
 pinMode(sens1, INPUT);
 pinMode(sens2,INPUT);
 pinMode(sens3,INPUT);
 pinMode(sens4,INPUT);

}

void loop () {
  //detección de dedos:



  dedo1 = analogRead(sens1);
  dedo2 = analogRead(sens2);
  dedo3 = analogRead(sens3);
  dedo4 = analogRead(sens4);
  
//las variables min y max estan ahí porque cada vez que se conecta el sensor otra vez da un rango de valores
//distinto, entonces cada vez que podemos comprobamos esos valores y los usamos para mapear un porcentaje
//de flexión, por ende el input puede ser siempre distinto pero el output siempre va a ser de 0 a 100 

  //los dedos envian por puerto analogico un valor, en cuanto mas alto, mas flexionado el dedo
  //vamos a enviar esos datos al back end quien tiene que interpretarlos y enviar la "orden"
  if(dedo1 > 0) {
    conversor1(dedo1);
  }

  if(dedo2 > 0) {
    conversor2(dedo2);
  }

  if(dedo3 > 0) {
    conversor3(dedo3);
  }

  if(dedo4 > 0) {
    conversor4(dedo4);
  }

  //movimiento de motores:
  //Lo que se va a hacer es mover las ruedas de una u otra forma dependiendo de la orden que llegue
  //desde una computadora por el puerto serie. Cada orden tiene un nombre como "adelante" o 
  //"Derecha"
  
  if (Serial.available () > 0) {
    orden = Serial.readString();
    if (orden == "Adelante") { //los motores tienen que ir a contra-reloj
      digitalWrite(IN1, HIGH);
      digitalWrite(IN2, LOW);
      analogWrite(ENA, velocidad);
      analogWrite(ENB, velocidad);
      digitalWrite(IN3, HIGH);
      digitalWrite(IN4, LOW);
      Serial.println("adelante");
    }
    //ENB está del lado derecho del puente h y ENA está del lado izquierdo (mirando desde el lado donde estan los IN y VCC)
    if (orden == "Izquierda") {
      analogWrite(ENA, 0);
      analogWrite(ENB, velocidad);
      digitalWrite(IN3, HIGH);
      digitalWrite(IN4 , LOW);
      Serial.println("izquierda");
    }

    if (orden == "Derecha") {
      analogWrite(ENB, 0);
      analogWrite(ENA, velocidad);
      digitalWrite(IN1, HIGH);
      digitalWrite(IN2, LOW);
      Serial.println("derecha");
    }

    if (orden == "Atras") {
      analogWrite(ENA, velocidad);
      analogWrite(ENB, velocidad);
      digitalWrite(IN2, HIGH);
      digitalWrite(IN4, HIGH);
      digitalWrite(IN1, LOW);
      digitalWrite(IN3, LOW);
      Serial.println("atras");
    }
    //estos de aca es para que el auto pueda doblar yendo en reversa, es lo mismo que los de derecha e izquierda
    //pero con los IN1 e IN2, IN3 e IN4 invertidos
    if (orden == "Izquierda r") {
      analogWrite(ENA, 0);
      analogWrite(ENB, velocidad);
      digitalWrite(IN3, LOW);
      digitalWrite(IN4 , HIGH);
      Serial.println("izquierda r");
    }
    if (orden == "Derecha r") {
      analogWrite(ENB, 0);
      analogWrite(ENA, velocidad);
      digitalWrite(IN1, LOW);
      digitalWrite(IN2, HIGH);
      Serial.println("derecha r");
    }
    else {
      analogWrite(ENA, 0);
      analogWrite(ENB, 0);
    }
    
  }
  delay(100);
}
/*
Vamos a hacer un código que saltee la comunicación serial para poder mover el hardware
independientemente del backend, que aún no ha terminado la comunicación con serialport. La idea es que 
detectemos los inputs de los dedos y en base a eso se le asigne un commando (avanzar, retroceder, doblar, etc)
sin posibilidad de ser programado por el usuario
*/

//movimiento de motor
#define ENA 9
#define ENB 10
#define IN1 3
#define IN2 4
#define IN3 5
#define IN4 6
int velocidad = 200;

//detección de dedos
#define sens1 A0
#define sens2 A1
#define sens3 A2
#define sens4 A3

int dedo1 = 0;
int dedo2 = 0;
int dedo3 = 0;
int dedo4 = 0;

long max = 0;
long min = 1023;
int respuesta = 0;

String orden = "";
 // los flex sensors dan valores entre 535 y 565, asi que vamos a crear una función  que los convierta
 //en porcentaje

int conversor1 (int Valor) {
   respuesta = map(Valor, 470, 950, 0, 100);
  
  if (respuesta < 0) {
    respuesta = 0;
  }
  if (respuesta > 100) {
    respuesta = 100;
  }

  Serial.print ("dedo menique:");
  Serial.println(respuesta);
  return respuesta;
}

int conversor2 (int Valor) {
   respuesta = map(Valor, 470, 950, 0, 100);
  
  if (respuesta < 0) {
    respuesta = 0;
  }
  if (respuesta > 100) {
    respuesta = 100;
  }

  Serial.print ("dedo anular:");
  Serial.println(respuesta);
  return respuesta;
}

int conversor3 (int Valor) {
   respuesta = map(Valor, 470, 950, 0, 100);
  
  if (respuesta < 0) {
    respuesta = 0;
  }
  if (respuesta > 100) {
    respuesta = 100;
  }

  Serial.print ("dedo mayor:");
  Serial.println(respuesta);
  return respuesta;
}

int conversor4 (int Valor) {
   respuesta = map(Valor, 470, 950, 0, 100);

  if (respuesta < 0) {
    respuesta = 0;
  }
  if (respuesta > 100) {
    respuesta = 100;
  }

  Serial.print ("dedo indice:");
  Serial.println(respuesta);
  return respuesta;
}



void setup () {
 //movimiento de motor
 pinMode(3, OUTPUT); 
 pinMode(4,OUTPUT); 
 pinMode(9,OUTPUT);
 pinMode(5,OUTPUT); 
 pinMode(6,OUTPUT); 
 pinMode(10,OUTPUT);
 Serial.begin (9600);
 //detección de dedos
 pinMode(sens1, INPUT);
 pinMode(sens2,INPUT);
 pinMode(sens3,INPUT);
 pinMode(sens4,INPUT);

}

void loop () {
  //detección de dedos
  dedo1 = analogRead(sens1);
  dedo2 = analogRead(sens2);
  dedo3 = analogRead(sens3);
  dedo4 = analogRead(sens4);
  int orden1 = conversor1(dedo1);
  int orden2 = conversor2(dedo2);
  int orden3 = conversor3(dedo3);
  int orden4 = conversor4(dedo4);

  //movimiento de motores:
  
  if (orden1 > 40) { //los motores tienen que ir a contra-reloj
    analogWrite(ENA, velocidad);
    analogWrite(ENB, velocidad);
    digitalWrite(IN2, HIGH);
    digitalWrite(IN4, HIGH);
    digitalWrite(IN1, LOW);
    digitalWrite(IN3, LOW);
    Serial.println("atras");
  }else if (orden2 > 40) {
    analogWrite(ENB, 0);
    analogWrite(ENA, velocidad);
    digitalWrite(IN1, HIGH);
    digitalWrite(IN2, LOW);
    Serial.println("derecha");
  }else if (orden3 > 40) {
    digitalWrite(IN1, HIGH);
    digitalWrite(IN2, LOW);
    analogWrite(ENA, velocidad);
    analogWrite(ENB, velocidad);
    digitalWrite(IN3, HIGH);
    digitalWrite(IN4, LOW);
    Serial.println("adelante");
  }else if (orden4 > 40) {
    analogWrite(ENA, 0);
    analogWrite(ENB, velocidad);
    digitalWrite(IN3, HIGH);
    digitalWrite(IN4 , LOW);
    Serial.println("izquierda");
  }else {
      analogWrite(ENA, 0);
      analogWrite(ENB, 0);
    }
  delay(100);
}